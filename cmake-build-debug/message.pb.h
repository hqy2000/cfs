// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_message_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_message_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_message_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_message_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[8]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_message_2eproto;
class ACL;
class ACLDefaultTypeInternal;
extern ACLDefaultTypeInternal _ACL_default_instance_;
class ACLKey;
class ACLKeyDefaultTypeInternal;
extern ACLKeyDefaultTypeInternal _ACLKey_default_instance_;
class ACLValue;
class ACLValueDefaultTypeInternal;
extern ACLValueDefaultTypeInternal _ACLValue_default_instance_;
class DataKey;
class DataKeyDefaultTypeInternal;
extern DataKeyDefaultTypeInternal _DataKey_default_instance_;
class DataValue;
class DataValueDefaultTypeInternal;
extern DataValueDefaultTypeInternal _DataValue_default_instance_;
class Key;
class KeyDefaultTypeInternal;
extern KeyDefaultTypeInternal _Key_default_instance_;
class Signature;
class SignatureDefaultTypeInternal;
extern SignatureDefaultTypeInternal _Signature_default_instance_;
class Value;
class ValueDefaultTypeInternal;
extern ValueDefaultTypeInternal _Value_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::ACL* Arena::CreateMaybeMessage<::ACL>(Arena*);
template<> ::ACLKey* Arena::CreateMaybeMessage<::ACLKey>(Arena*);
template<> ::ACLValue* Arena::CreateMaybeMessage<::ACLValue>(Arena*);
template<> ::DataKey* Arena::CreateMaybeMessage<::DataKey>(Arena*);
template<> ::DataValue* Arena::CreateMaybeMessage<::DataValue>(Arena*);
template<> ::Key* Arena::CreateMaybeMessage<::Key>(Arena*);
template<> ::Signature* Arena::CreateMaybeMessage<::Signature>(Arena*);
template<> ::Value* Arena::CreateMaybeMessage<::Value>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class Key PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Key) */ {
 public:
  inline Key() : Key(nullptr) {};
  virtual ~Key();

  Key(const Key& from);
  Key(Key&& from) noexcept
    : Key() {
    *this = ::std::move(from);
  }

  inline Key& operator=(const Key& from) {
    CopyFrom(from);
    return *this;
  }
  inline Key& operator=(Key&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Key& default_instance();

  enum ContentCase {
    kAclKey = 1,
    kDataKey = 2,
    CONTENT_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Key* internal_default_instance() {
    return reinterpret_cast<const Key*>(
               &_Key_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Key& a, Key& b) {
    a.Swap(&b);
  }
  inline void Swap(Key* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Key* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Key* New() const final {
    return CreateMaybeMessage<Key>(nullptr);
  }

  Key* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Key>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Key& from);
  void MergeFrom(const Key& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Key* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Key";
  }
  protected:
  explicit Key(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2eproto);
    return ::descriptor_table_message_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAclKeyFieldNumber = 1,
    kDataKeyFieldNumber = 2,
  };
  // .ACLKey aclKey = 1;
  bool has_aclkey() const;
  private:
  bool _internal_has_aclkey() const;
  public:
  void clear_aclkey();
  const ::ACLKey& aclkey() const;
  ::ACLKey* release_aclkey();
  ::ACLKey* mutable_aclkey();
  void set_allocated_aclkey(::ACLKey* aclkey);
  private:
  const ::ACLKey& _internal_aclkey() const;
  ::ACLKey* _internal_mutable_aclkey();
  public:
  void unsafe_arena_set_allocated_aclkey(
      ::ACLKey* aclkey);
  ::ACLKey* unsafe_arena_release_aclkey();

  // .DataKey dataKey = 2;
  bool has_datakey() const;
  private:
  bool _internal_has_datakey() const;
  public:
  void clear_datakey();
  const ::DataKey& datakey() const;
  ::DataKey* release_datakey();
  ::DataKey* mutable_datakey();
  void set_allocated_datakey(::DataKey* datakey);
  private:
  const ::DataKey& _internal_datakey() const;
  ::DataKey* _internal_mutable_datakey();
  public:
  void unsafe_arena_set_allocated_datakey(
      ::DataKey* datakey);
  ::DataKey* unsafe_arena_release_datakey();

  void clear_content();
  ContentCase content_case() const;
  // @@protoc_insertion_point(class_scope:Key)
 private:
  class _Internal;
  void set_has_aclkey();
  void set_has_datakey();

  inline bool has_content() const;
  inline void clear_has_content();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ContentUnion {
    ContentUnion() {}
    ::ACLKey* aclkey_;
    ::DataKey* datakey_;
  } content_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class Value PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Value) */ {
 public:
  inline Value() : Value(nullptr) {};
  virtual ~Value();

  Value(const Value& from);
  Value(Value&& from) noexcept
    : Value() {
    *this = ::std::move(from);
  }

  inline Value& operator=(const Value& from) {
    CopyFrom(from);
    return *this;
  }
  inline Value& operator=(Value&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Value& default_instance();

  enum ContentCase {
    kAclValue = 1,
    kDataValue = 2,
    CONTENT_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Value* internal_default_instance() {
    return reinterpret_cast<const Value*>(
               &_Value_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Value& a, Value& b) {
    a.Swap(&b);
  }
  inline void Swap(Value* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Value* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Value* New() const final {
    return CreateMaybeMessage<Value>(nullptr);
  }

  Value* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Value>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Value& from);
  void MergeFrom(const Value& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Value* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Value";
  }
  protected:
  explicit Value(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2eproto);
    return ::descriptor_table_message_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAclValueFieldNumber = 1,
    kDataValueFieldNumber = 2,
  };
  // .ACLValue aclValue = 1;
  bool has_aclvalue() const;
  private:
  bool _internal_has_aclvalue() const;
  public:
  void clear_aclvalue();
  const ::ACLValue& aclvalue() const;
  ::ACLValue* release_aclvalue();
  ::ACLValue* mutable_aclvalue();
  void set_allocated_aclvalue(::ACLValue* aclvalue);
  private:
  const ::ACLValue& _internal_aclvalue() const;
  ::ACLValue* _internal_mutable_aclvalue();
  public:
  void unsafe_arena_set_allocated_aclvalue(
      ::ACLValue* aclvalue);
  ::ACLValue* unsafe_arena_release_aclvalue();

  // .DataValue dataValue = 2;
  bool has_datavalue() const;
  private:
  bool _internal_has_datavalue() const;
  public:
  void clear_datavalue();
  const ::DataValue& datavalue() const;
  ::DataValue* release_datavalue();
  ::DataValue* mutable_datavalue();
  void set_allocated_datavalue(::DataValue* datavalue);
  private:
  const ::DataValue& _internal_datavalue() const;
  ::DataValue* _internal_mutable_datavalue();
  public:
  void unsafe_arena_set_allocated_datavalue(
      ::DataValue* datavalue);
  ::DataValue* unsafe_arena_release_datavalue();

  void clear_content();
  ContentCase content_case() const;
  // @@protoc_insertion_point(class_scope:Value)
 private:
  class _Internal;
  void set_has_aclvalue();
  void set_has_datavalue();

  inline bool has_content() const;
  inline void clear_has_content();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ContentUnion {
    ContentUnion() {}
    ::ACLValue* aclvalue_;
    ::DataValue* datavalue_;
  } content_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class ACLKey PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ACLKey) */ {
 public:
  inline ACLKey() : ACLKey(nullptr) {};
  virtual ~ACLKey();

  ACLKey(const ACLKey& from);
  ACLKey(ACLKey&& from) noexcept
    : ACLKey() {
    *this = ::std::move(from);
  }

  inline ACLKey& operator=(const ACLKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline ACLKey& operator=(ACLKey&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ACLKey& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ACLKey* internal_default_instance() {
    return reinterpret_cast<const ACLKey*>(
               &_ACLKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ACLKey& a, ACLKey& b) {
    a.Swap(&b);
  }
  inline void Swap(ACLKey* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ACLKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ACLKey* New() const final {
    return CreateMaybeMessage<ACLKey>(nullptr);
  }

  ACLKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ACLKey>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ACLKey& from);
  void MergeFrom(const ACLKey& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ACLKey* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ACLKey";
  }
  protected:
  explicit ACLKey(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2eproto);
    return ::descriptor_table_message_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWriteIdFieldNumber = 1,
  };
  // bytes writeId = 1;
  void clear_writeid();
  const std::string& writeid() const;
  void set_writeid(const std::string& value);
  void set_writeid(std::string&& value);
  void set_writeid(const char* value);
  void set_writeid(const void* value, size_t size);
  std::string* mutable_writeid();
  std::string* release_writeid();
  void set_allocated_writeid(std::string* writeid);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_writeid();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_writeid(
      std::string* writeid);
  private:
  const std::string& _internal_writeid() const;
  void _internal_set_writeid(const std::string& value);
  std::string* _internal_mutable_writeid();
  public:

  // @@protoc_insertion_point(class_scope:ACLKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr writeid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class DataKey PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DataKey) */ {
 public:
  inline DataKey() : DataKey(nullptr) {};
  virtual ~DataKey();

  DataKey(const DataKey& from);
  DataKey(DataKey&& from) noexcept
    : DataKey() {
    *this = ::std::move(from);
  }

  inline DataKey& operator=(const DataKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataKey& operator=(DataKey&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DataKey& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DataKey* internal_default_instance() {
    return reinterpret_cast<const DataKey*>(
               &_DataKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(DataKey& a, DataKey& b) {
    a.Swap(&b);
  }
  inline void Swap(DataKey* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DataKey* New() const final {
    return CreateMaybeMessage<DataKey>(nullptr);
  }

  DataKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DataKey>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DataKey& from);
  void MergeFrom(const DataKey& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataKey* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DataKey";
  }
  protected:
  explicit DataKey(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2eproto);
    return ::descriptor_table_message_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
    kIsFolderFieldNumber = 2,
  };
  // repeated bytes path = 1;
  int path_size() const;
  private:
  int _internal_path_size() const;
  public:
  void clear_path();
  const std::string& path(int index) const;
  std::string* mutable_path(int index);
  void set_path(int index, const std::string& value);
  void set_path(int index, std::string&& value);
  void set_path(int index, const char* value);
  void set_path(int index, const void* value, size_t size);
  std::string* add_path();
  void add_path(const std::string& value);
  void add_path(std::string&& value);
  void add_path(const char* value);
  void add_path(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& path() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_path();
  private:
  const std::string& _internal_path(int index) const;
  std::string* _internal_add_path();
  public:

  // bool isFolder = 2;
  void clear_isfolder();
  bool isfolder() const;
  void set_isfolder(bool value);
  private:
  bool _internal_isfolder() const;
  void _internal_set_isfolder(bool value);
  public:

  // @@protoc_insertion_point(class_scope:DataKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> path_;
  bool isfolder_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class ACLValue PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ACLValue) */ {
 public:
  inline ACLValue() : ACLValue(nullptr) {};
  virtual ~ACLValue();

  ACLValue(const ACLValue& from);
  ACLValue(ACLValue&& from) noexcept
    : ACLValue() {
    *this = ::std::move(from);
  }

  inline ACLValue& operator=(const ACLValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline ACLValue& operator=(ACLValue&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ACLValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ACLValue* internal_default_instance() {
    return reinterpret_cast<const ACLValue*>(
               &_ACLValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ACLValue& a, ACLValue& b) {
    a.Swap(&b);
  }
  inline void Swap(ACLValue* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ACLValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ACLValue* New() const final {
    return CreateMaybeMessage<ACLValue>(nullptr);
  }

  ACLValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ACLValue>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ACLValue& from);
  void MergeFrom(const ACLValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ACLValue* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ACLValue";
  }
  protected:
  explicit ACLValue(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2eproto);
    return ::descriptor_table_message_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAclFieldNumber = 1,
  };
  // repeated .ACL acl = 1;
  int acl_size() const;
  private:
  int _internal_acl_size() const;
  public:
  void clear_acl();
  ::ACL* mutable_acl(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ACL >*
      mutable_acl();
  private:
  const ::ACL& _internal_acl(int index) const;
  ::ACL* _internal_add_acl();
  public:
  const ::ACL& acl(int index) const;
  ::ACL* add_acl();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ACL >&
      acl() const;

  // @@protoc_insertion_point(class_scope:ACLValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ACL > acl_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class ACL PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ACL) */ {
 public:
  inline ACL() : ACL(nullptr) {};
  virtual ~ACL();

  ACL(const ACL& from);
  ACL(ACL&& from) noexcept
    : ACL() {
    *this = ::std::move(from);
  }

  inline ACL& operator=(const ACL& from) {
    CopyFrom(from);
    return *this;
  }
  inline ACL& operator=(ACL&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ACL& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ACL* internal_default_instance() {
    return reinterpret_cast<const ACL*>(
               &_ACL_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ACL& a, ACL& b) {
    a.Swap(&b);
  }
  inline void Swap(ACL* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ACL* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ACL* New() const final {
    return CreateMaybeMessage<ACL>(nullptr);
  }

  ACL* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ACL>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ACL& from);
  void MergeFrom(const ACL& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ACL* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ACL";
  }
  protected:
  explicit ACL(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2eproto);
    return ::descriptor_table_message_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPublicKeyFieldNumber = 1,
    kUidFieldNumber = 2,
  };
  // bytes publicKey = 1;
  void clear_publickey();
  const std::string& publickey() const;
  void set_publickey(const std::string& value);
  void set_publickey(std::string&& value);
  void set_publickey(const char* value);
  void set_publickey(const void* value, size_t size);
  std::string* mutable_publickey();
  std::string* release_publickey();
  void set_allocated_publickey(std::string* publickey);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_publickey();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_publickey(
      std::string* publickey);
  private:
  const std::string& _internal_publickey() const;
  void _internal_set_publickey(const std::string& value);
  std::string* _internal_mutable_publickey();
  public:

  // int32 uid = 2;
  void clear_uid();
  ::PROTOBUF_NAMESPACE_ID::int32 uid() const;
  void set_uid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_uid() const;
  void _internal_set_uid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:ACL)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr publickey_;
  ::PROTOBUF_NAMESPACE_ID::int32 uid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class DataValue PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DataValue) */ {
 public:
  inline DataValue() : DataValue(nullptr) {};
  virtual ~DataValue();

  DataValue(const DataValue& from);
  DataValue(DataValue&& from) noexcept
    : DataValue() {
    *this = ::std::move(from);
  }

  inline DataValue& operator=(const DataValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataValue& operator=(DataValue&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DataValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DataValue* internal_default_instance() {
    return reinterpret_cast<const DataValue*>(
               &_DataValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(DataValue& a, DataValue& b) {
    a.Swap(&b);
  }
  inline void Swap(DataValue* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DataValue* New() const final {
    return CreateMaybeMessage<DataValue>(nullptr);
  }

  DataValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DataValue>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DataValue& from);
  void MergeFrom(const DataValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataValue* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DataValue";
  }
  protected:
  explicit DataValue(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2eproto);
    return ::descriptor_table_message_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kSignatureFieldNumber = 1000,
  };
  // bytes data = 1;
  void clear_data();
  const std::string& data() const;
  void set_data(const std::string& value);
  void set_data(std::string&& value);
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  std::string* mutable_data();
  std::string* release_data();
  void set_allocated_data(std::string* data);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_data();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_data(
      std::string* data);
  private:
  const std::string& _internal_data() const;
  void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // .Signature signature = 1000;
  bool has_signature() const;
  private:
  bool _internal_has_signature() const;
  public:
  void clear_signature();
  const ::Signature& signature() const;
  ::Signature* release_signature();
  ::Signature* mutable_signature();
  void set_allocated_signature(::Signature* signature);
  private:
  const ::Signature& _internal_signature() const;
  ::Signature* _internal_mutable_signature();
  public:
  void unsafe_arena_set_allocated_signature(
      ::Signature* signature);
  ::Signature* unsafe_arena_release_signature();

  // @@protoc_insertion_point(class_scope:DataValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  ::Signature* signature_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class Signature PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Signature) */ {
 public:
  inline Signature() : Signature(nullptr) {};
  virtual ~Signature();

  Signature(const Signature& from);
  Signature(Signature&& from) noexcept
    : Signature() {
    *this = ::std::move(from);
  }

  inline Signature& operator=(const Signature& from) {
    CopyFrom(from);
    return *this;
  }
  inline Signature& operator=(Signature&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Signature& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Signature* internal_default_instance() {
    return reinterpret_cast<const Signature*>(
               &_Signature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Signature& a, Signature& b) {
    a.Swap(&b);
  }
  inline void Swap(Signature* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Signature* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Signature* New() const final {
    return CreateMaybeMessage<Signature>(nullptr);
  }

  Signature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Signature>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Signature& from);
  void MergeFrom(const Signature& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Signature* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Signature";
  }
  protected:
  explicit Signature(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2eproto);
    return ::descriptor_table_message_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignatureFieldNumber = 1,
    kWriterFieldNumber = 2,
    kUserIdFieldNumber = 3,
  };
  // bytes signature = 1;
  void clear_signature();
  const std::string& signature() const;
  void set_signature(const std::string& value);
  void set_signature(std::string&& value);
  void set_signature(const char* value);
  void set_signature(const void* value, size_t size);
  std::string* mutable_signature();
  std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_signature();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_signature(
      std::string* signature);
  private:
  const std::string& _internal_signature() const;
  void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // .ACLKey writer = 2;
  bool has_writer() const;
  private:
  bool _internal_has_writer() const;
  public:
  void clear_writer();
  const ::ACLKey& writer() const;
  ::ACLKey* release_writer();
  ::ACLKey* mutable_writer();
  void set_allocated_writer(::ACLKey* writer);
  private:
  const ::ACLKey& _internal_writer() const;
  ::ACLKey* _internal_mutable_writer();
  public:
  void unsafe_arena_set_allocated_writer(
      ::ACLKey* writer);
  ::ACLKey* unsafe_arena_release_writer();

  // int32 userId = 3;
  void clear_userid();
  ::PROTOBUF_NAMESPACE_ID::int32 userid() const;
  void set_userid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_userid() const;
  void _internal_set_userid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:Signature)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
  ::ACLKey* writer_;
  ::PROTOBUF_NAMESPACE_ID::int32 userid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Key

// .ACLKey aclKey = 1;
inline bool Key::_internal_has_aclkey() const {
  return content_case() == kAclKey;
}
inline bool Key::has_aclkey() const {
  return _internal_has_aclkey();
}
inline void Key::set_has_aclkey() {
  _oneof_case_[0] = kAclKey;
}
inline void Key::clear_aclkey() {
  if (_internal_has_aclkey()) {
    if (GetArena() == nullptr) {
      delete content_.aclkey_;
    }
    clear_has_content();
  }
}
inline ::ACLKey* Key::release_aclkey() {
  // @@protoc_insertion_point(field_release:Key.aclKey)
  if (_internal_has_aclkey()) {
    clear_has_content();
      ::ACLKey* temp = content_.aclkey_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    content_.aclkey_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ACLKey& Key::_internal_aclkey() const {
  return _internal_has_aclkey()
      ? *content_.aclkey_
      : *reinterpret_cast< ::ACLKey*>(&::_ACLKey_default_instance_);
}
inline const ::ACLKey& Key::aclkey() const {
  // @@protoc_insertion_point(field_get:Key.aclKey)
  return _internal_aclkey();
}
inline ::ACLKey* Key::unsafe_arena_release_aclkey() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Key.aclKey)
  if (_internal_has_aclkey()) {
    clear_has_content();
    ::ACLKey* temp = content_.aclkey_;
    content_.aclkey_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Key::unsafe_arena_set_allocated_aclkey(::ACLKey* aclkey) {
  clear_content();
  if (aclkey) {
    set_has_aclkey();
    content_.aclkey_ = aclkey;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Key.aclKey)
}
inline ::ACLKey* Key::_internal_mutable_aclkey() {
  if (!_internal_has_aclkey()) {
    clear_content();
    set_has_aclkey();
    content_.aclkey_ = CreateMaybeMessage< ::ACLKey >(GetArena());
  }
  return content_.aclkey_;
}
inline ::ACLKey* Key::mutable_aclkey() {
  // @@protoc_insertion_point(field_mutable:Key.aclKey)
  return _internal_mutable_aclkey();
}

// .DataKey dataKey = 2;
inline bool Key::_internal_has_datakey() const {
  return content_case() == kDataKey;
}
inline bool Key::has_datakey() const {
  return _internal_has_datakey();
}
inline void Key::set_has_datakey() {
  _oneof_case_[0] = kDataKey;
}
inline void Key::clear_datakey() {
  if (_internal_has_datakey()) {
    if (GetArena() == nullptr) {
      delete content_.datakey_;
    }
    clear_has_content();
  }
}
inline ::DataKey* Key::release_datakey() {
  // @@protoc_insertion_point(field_release:Key.dataKey)
  if (_internal_has_datakey()) {
    clear_has_content();
      ::DataKey* temp = content_.datakey_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    content_.datakey_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::DataKey& Key::_internal_datakey() const {
  return _internal_has_datakey()
      ? *content_.datakey_
      : *reinterpret_cast< ::DataKey*>(&::_DataKey_default_instance_);
}
inline const ::DataKey& Key::datakey() const {
  // @@protoc_insertion_point(field_get:Key.dataKey)
  return _internal_datakey();
}
inline ::DataKey* Key::unsafe_arena_release_datakey() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Key.dataKey)
  if (_internal_has_datakey()) {
    clear_has_content();
    ::DataKey* temp = content_.datakey_;
    content_.datakey_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Key::unsafe_arena_set_allocated_datakey(::DataKey* datakey) {
  clear_content();
  if (datakey) {
    set_has_datakey();
    content_.datakey_ = datakey;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Key.dataKey)
}
inline ::DataKey* Key::_internal_mutable_datakey() {
  if (!_internal_has_datakey()) {
    clear_content();
    set_has_datakey();
    content_.datakey_ = CreateMaybeMessage< ::DataKey >(GetArena());
  }
  return content_.datakey_;
}
inline ::DataKey* Key::mutable_datakey() {
  // @@protoc_insertion_point(field_mutable:Key.dataKey)
  return _internal_mutable_datakey();
}

inline bool Key::has_content() const {
  return content_case() != CONTENT_NOT_SET;
}
inline void Key::clear_has_content() {
  _oneof_case_[0] = CONTENT_NOT_SET;
}
inline Key::ContentCase Key::content_case() const {
  return Key::ContentCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Value

// .ACLValue aclValue = 1;
inline bool Value::_internal_has_aclvalue() const {
  return content_case() == kAclValue;
}
inline bool Value::has_aclvalue() const {
  return _internal_has_aclvalue();
}
inline void Value::set_has_aclvalue() {
  _oneof_case_[0] = kAclValue;
}
inline void Value::clear_aclvalue() {
  if (_internal_has_aclvalue()) {
    if (GetArena() == nullptr) {
      delete content_.aclvalue_;
    }
    clear_has_content();
  }
}
inline ::ACLValue* Value::release_aclvalue() {
  // @@protoc_insertion_point(field_release:Value.aclValue)
  if (_internal_has_aclvalue()) {
    clear_has_content();
      ::ACLValue* temp = content_.aclvalue_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    content_.aclvalue_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ACLValue& Value::_internal_aclvalue() const {
  return _internal_has_aclvalue()
      ? *content_.aclvalue_
      : *reinterpret_cast< ::ACLValue*>(&::_ACLValue_default_instance_);
}
inline const ::ACLValue& Value::aclvalue() const {
  // @@protoc_insertion_point(field_get:Value.aclValue)
  return _internal_aclvalue();
}
inline ::ACLValue* Value::unsafe_arena_release_aclvalue() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Value.aclValue)
  if (_internal_has_aclvalue()) {
    clear_has_content();
    ::ACLValue* temp = content_.aclvalue_;
    content_.aclvalue_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Value::unsafe_arena_set_allocated_aclvalue(::ACLValue* aclvalue) {
  clear_content();
  if (aclvalue) {
    set_has_aclvalue();
    content_.aclvalue_ = aclvalue;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Value.aclValue)
}
inline ::ACLValue* Value::_internal_mutable_aclvalue() {
  if (!_internal_has_aclvalue()) {
    clear_content();
    set_has_aclvalue();
    content_.aclvalue_ = CreateMaybeMessage< ::ACLValue >(GetArena());
  }
  return content_.aclvalue_;
}
inline ::ACLValue* Value::mutable_aclvalue() {
  // @@protoc_insertion_point(field_mutable:Value.aclValue)
  return _internal_mutable_aclvalue();
}

// .DataValue dataValue = 2;
inline bool Value::_internal_has_datavalue() const {
  return content_case() == kDataValue;
}
inline bool Value::has_datavalue() const {
  return _internal_has_datavalue();
}
inline void Value::set_has_datavalue() {
  _oneof_case_[0] = kDataValue;
}
inline void Value::clear_datavalue() {
  if (_internal_has_datavalue()) {
    if (GetArena() == nullptr) {
      delete content_.datavalue_;
    }
    clear_has_content();
  }
}
inline ::DataValue* Value::release_datavalue() {
  // @@protoc_insertion_point(field_release:Value.dataValue)
  if (_internal_has_datavalue()) {
    clear_has_content();
      ::DataValue* temp = content_.datavalue_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    content_.datavalue_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::DataValue& Value::_internal_datavalue() const {
  return _internal_has_datavalue()
      ? *content_.datavalue_
      : *reinterpret_cast< ::DataValue*>(&::_DataValue_default_instance_);
}
inline const ::DataValue& Value::datavalue() const {
  // @@protoc_insertion_point(field_get:Value.dataValue)
  return _internal_datavalue();
}
inline ::DataValue* Value::unsafe_arena_release_datavalue() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Value.dataValue)
  if (_internal_has_datavalue()) {
    clear_has_content();
    ::DataValue* temp = content_.datavalue_;
    content_.datavalue_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Value::unsafe_arena_set_allocated_datavalue(::DataValue* datavalue) {
  clear_content();
  if (datavalue) {
    set_has_datavalue();
    content_.datavalue_ = datavalue;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Value.dataValue)
}
inline ::DataValue* Value::_internal_mutable_datavalue() {
  if (!_internal_has_datavalue()) {
    clear_content();
    set_has_datavalue();
    content_.datavalue_ = CreateMaybeMessage< ::DataValue >(GetArena());
  }
  return content_.datavalue_;
}
inline ::DataValue* Value::mutable_datavalue() {
  // @@protoc_insertion_point(field_mutable:Value.dataValue)
  return _internal_mutable_datavalue();
}

inline bool Value::has_content() const {
  return content_case() != CONTENT_NOT_SET;
}
inline void Value::clear_has_content() {
  _oneof_case_[0] = CONTENT_NOT_SET;
}
inline Value::ContentCase Value::content_case() const {
  return Value::ContentCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ACLKey

// bytes writeId = 1;
inline void ACLKey::clear_writeid() {
  writeid_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ACLKey::writeid() const {
  // @@protoc_insertion_point(field_get:ACLKey.writeId)
  return _internal_writeid();
}
inline void ACLKey::set_writeid(const std::string& value) {
  _internal_set_writeid(value);
  // @@protoc_insertion_point(field_set:ACLKey.writeId)
}
inline std::string* ACLKey::mutable_writeid() {
  // @@protoc_insertion_point(field_mutable:ACLKey.writeId)
  return _internal_mutable_writeid();
}
inline const std::string& ACLKey::_internal_writeid() const {
  return writeid_.Get();
}
inline void ACLKey::_internal_set_writeid(const std::string& value) {
  
  writeid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ACLKey::set_writeid(std::string&& value) {
  
  writeid_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ACLKey.writeId)
}
inline void ACLKey::set_writeid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  writeid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ACLKey.writeId)
}
inline void ACLKey::set_writeid(const void* value,
    size_t size) {
  
  writeid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ACLKey.writeId)
}
inline std::string* ACLKey::_internal_mutable_writeid() {
  
  return writeid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ACLKey::release_writeid() {
  // @@protoc_insertion_point(field_release:ACLKey.writeId)
  return writeid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ACLKey::set_allocated_writeid(std::string* writeid) {
  if (writeid != nullptr) {
    
  } else {
    
  }
  writeid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), writeid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ACLKey.writeId)
}
inline std::string* ACLKey::unsafe_arena_release_writeid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ACLKey.writeId)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return writeid_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ACLKey::unsafe_arena_set_allocated_writeid(
    std::string* writeid) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (writeid != nullptr) {
    
  } else {
    
  }
  writeid_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      writeid, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ACLKey.writeId)
}

// -------------------------------------------------------------------

// DataKey

// repeated bytes path = 1;
inline int DataKey::_internal_path_size() const {
  return path_.size();
}
inline int DataKey::path_size() const {
  return _internal_path_size();
}
inline void DataKey::clear_path() {
  path_.Clear();
}
inline std::string* DataKey::add_path() {
  // @@protoc_insertion_point(field_add_mutable:DataKey.path)
  return _internal_add_path();
}
inline const std::string& DataKey::_internal_path(int index) const {
  return path_.Get(index);
}
inline const std::string& DataKey::path(int index) const {
  // @@protoc_insertion_point(field_get:DataKey.path)
  return _internal_path(index);
}
inline std::string* DataKey::mutable_path(int index) {
  // @@protoc_insertion_point(field_mutable:DataKey.path)
  return path_.Mutable(index);
}
inline void DataKey::set_path(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:DataKey.path)
  path_.Mutable(index)->assign(value);
}
inline void DataKey::set_path(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:DataKey.path)
  path_.Mutable(index)->assign(std::move(value));
}
inline void DataKey::set_path(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  path_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:DataKey.path)
}
inline void DataKey::set_path(int index, const void* value, size_t size) {
  path_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DataKey.path)
}
inline std::string* DataKey::_internal_add_path() {
  return path_.Add();
}
inline void DataKey::add_path(const std::string& value) {
  path_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:DataKey.path)
}
inline void DataKey::add_path(std::string&& value) {
  path_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:DataKey.path)
}
inline void DataKey::add_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  path_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:DataKey.path)
}
inline void DataKey::add_path(const void* value, size_t size) {
  path_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:DataKey.path)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DataKey::path() const {
  // @@protoc_insertion_point(field_list:DataKey.path)
  return path_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DataKey::mutable_path() {
  // @@protoc_insertion_point(field_mutable_list:DataKey.path)
  return &path_;
}

// bool isFolder = 2;
inline void DataKey::clear_isfolder() {
  isfolder_ = false;
}
inline bool DataKey::_internal_isfolder() const {
  return isfolder_;
}
inline bool DataKey::isfolder() const {
  // @@protoc_insertion_point(field_get:DataKey.isFolder)
  return _internal_isfolder();
}
inline void DataKey::_internal_set_isfolder(bool value) {
  
  isfolder_ = value;
}
inline void DataKey::set_isfolder(bool value) {
  _internal_set_isfolder(value);
  // @@protoc_insertion_point(field_set:DataKey.isFolder)
}

// -------------------------------------------------------------------

// ACLValue

// repeated .ACL acl = 1;
inline int ACLValue::_internal_acl_size() const {
  return acl_.size();
}
inline int ACLValue::acl_size() const {
  return _internal_acl_size();
}
inline void ACLValue::clear_acl() {
  acl_.Clear();
}
inline ::ACL* ACLValue::mutable_acl(int index) {
  // @@protoc_insertion_point(field_mutable:ACLValue.acl)
  return acl_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ACL >*
ACLValue::mutable_acl() {
  // @@protoc_insertion_point(field_mutable_list:ACLValue.acl)
  return &acl_;
}
inline const ::ACL& ACLValue::_internal_acl(int index) const {
  return acl_.Get(index);
}
inline const ::ACL& ACLValue::acl(int index) const {
  // @@protoc_insertion_point(field_get:ACLValue.acl)
  return _internal_acl(index);
}
inline ::ACL* ACLValue::_internal_add_acl() {
  return acl_.Add();
}
inline ::ACL* ACLValue::add_acl() {
  // @@protoc_insertion_point(field_add:ACLValue.acl)
  return _internal_add_acl();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ACL >&
ACLValue::acl() const {
  // @@protoc_insertion_point(field_list:ACLValue.acl)
  return acl_;
}

// -------------------------------------------------------------------

// ACL

// bytes publicKey = 1;
inline void ACL::clear_publickey() {
  publickey_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ACL::publickey() const {
  // @@protoc_insertion_point(field_get:ACL.publicKey)
  return _internal_publickey();
}
inline void ACL::set_publickey(const std::string& value) {
  _internal_set_publickey(value);
  // @@protoc_insertion_point(field_set:ACL.publicKey)
}
inline std::string* ACL::mutable_publickey() {
  // @@protoc_insertion_point(field_mutable:ACL.publicKey)
  return _internal_mutable_publickey();
}
inline const std::string& ACL::_internal_publickey() const {
  return publickey_.Get();
}
inline void ACL::_internal_set_publickey(const std::string& value) {
  
  publickey_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ACL::set_publickey(std::string&& value) {
  
  publickey_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ACL.publicKey)
}
inline void ACL::set_publickey(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  publickey_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ACL.publicKey)
}
inline void ACL::set_publickey(const void* value,
    size_t size) {
  
  publickey_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ACL.publicKey)
}
inline std::string* ACL::_internal_mutable_publickey() {
  
  return publickey_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ACL::release_publickey() {
  // @@protoc_insertion_point(field_release:ACL.publicKey)
  return publickey_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ACL::set_allocated_publickey(std::string* publickey) {
  if (publickey != nullptr) {
    
  } else {
    
  }
  publickey_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), publickey,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ACL.publicKey)
}
inline std::string* ACL::unsafe_arena_release_publickey() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ACL.publicKey)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return publickey_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ACL::unsafe_arena_set_allocated_publickey(
    std::string* publickey) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (publickey != nullptr) {
    
  } else {
    
  }
  publickey_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      publickey, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ACL.publicKey)
}

// int32 uid = 2;
inline void ACL::clear_uid() {
  uid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ACL::_internal_uid() const {
  return uid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ACL::uid() const {
  // @@protoc_insertion_point(field_get:ACL.uid)
  return _internal_uid();
}
inline void ACL::_internal_set_uid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  uid_ = value;
}
inline void ACL::set_uid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_uid(value);
  // @@protoc_insertion_point(field_set:ACL.uid)
}

// -------------------------------------------------------------------

// DataValue

// bytes data = 1;
inline void DataValue::clear_data() {
  data_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& DataValue::data() const {
  // @@protoc_insertion_point(field_get:DataValue.data)
  return _internal_data();
}
inline void DataValue::set_data(const std::string& value) {
  _internal_set_data(value);
  // @@protoc_insertion_point(field_set:DataValue.data)
}
inline std::string* DataValue::mutable_data() {
  // @@protoc_insertion_point(field_mutable:DataValue.data)
  return _internal_mutable_data();
}
inline const std::string& DataValue::_internal_data() const {
  return data_.Get();
}
inline void DataValue::_internal_set_data(const std::string& value) {
  
  data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void DataValue::set_data(std::string&& value) {
  
  data_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:DataValue.data)
}
inline void DataValue::set_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:DataValue.data)
}
inline void DataValue::set_data(const void* value,
    size_t size) {
  
  data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:DataValue.data)
}
inline std::string* DataValue::_internal_mutable_data() {
  
  return data_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* DataValue::release_data() {
  // @@protoc_insertion_point(field_release:DataValue.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DataValue::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:DataValue.data)
}
inline std::string* DataValue::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:DataValue.data)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return data_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void DataValue::unsafe_arena_set_allocated_data(
    std::string* data) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (data != nullptr) {
    
  } else {
    
  }
  data_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      data, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DataValue.data)
}

// .Signature signature = 1000;
inline bool DataValue::_internal_has_signature() const {
  return this != internal_default_instance() && signature_ != nullptr;
}
inline bool DataValue::has_signature() const {
  return _internal_has_signature();
}
inline void DataValue::clear_signature() {
  if (GetArena() == nullptr && signature_ != nullptr) {
    delete signature_;
  }
  signature_ = nullptr;
}
inline const ::Signature& DataValue::_internal_signature() const {
  const ::Signature* p = signature_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Signature*>(
      &::_Signature_default_instance_);
}
inline const ::Signature& DataValue::signature() const {
  // @@protoc_insertion_point(field_get:DataValue.signature)
  return _internal_signature();
}
inline void DataValue::unsafe_arena_set_allocated_signature(
    ::Signature* signature) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(signature_);
  }
  signature_ = signature;
  if (signature) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DataValue.signature)
}
inline ::Signature* DataValue::release_signature() {
  auto temp = unsafe_arena_release_signature();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Signature* DataValue::unsafe_arena_release_signature() {
  // @@protoc_insertion_point(field_release:DataValue.signature)
  
  ::Signature* temp = signature_;
  signature_ = nullptr;
  return temp;
}
inline ::Signature* DataValue::_internal_mutable_signature() {
  
  if (signature_ == nullptr) {
    auto* p = CreateMaybeMessage<::Signature>(GetArena());
    signature_ = p;
  }
  return signature_;
}
inline ::Signature* DataValue::mutable_signature() {
  // @@protoc_insertion_point(field_mutable:DataValue.signature)
  return _internal_mutable_signature();
}
inline void DataValue::set_allocated_signature(::Signature* signature) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete signature_;
  }
  if (signature) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(signature);
    if (message_arena != submessage_arena) {
      signature = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, signature, submessage_arena);
    }
    
  } else {
    
  }
  signature_ = signature;
  // @@protoc_insertion_point(field_set_allocated:DataValue.signature)
}

// -------------------------------------------------------------------

// Signature

// bytes signature = 1;
inline void Signature::clear_signature() {
  signature_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Signature::signature() const {
  // @@protoc_insertion_point(field_get:Signature.signature)
  return _internal_signature();
}
inline void Signature::set_signature(const std::string& value) {
  _internal_set_signature(value);
  // @@protoc_insertion_point(field_set:Signature.signature)
}
inline std::string* Signature::mutable_signature() {
  // @@protoc_insertion_point(field_mutable:Signature.signature)
  return _internal_mutable_signature();
}
inline const std::string& Signature::_internal_signature() const {
  return signature_.Get();
}
inline void Signature::_internal_set_signature(const std::string& value) {
  
  signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Signature::set_signature(std::string&& value) {
  
  signature_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:Signature.signature)
}
inline void Signature::set_signature(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:Signature.signature)
}
inline void Signature::set_signature(const void* value,
    size_t size) {
  
  signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:Signature.signature)
}
inline std::string* Signature::_internal_mutable_signature() {
  
  return signature_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Signature::release_signature() {
  // @@protoc_insertion_point(field_release:Signature.signature)
  return signature_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Signature::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    
  } else {
    
  }
  signature_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signature,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:Signature.signature)
}
inline std::string* Signature::unsafe_arena_release_signature() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Signature.signature)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return signature_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Signature::unsafe_arena_set_allocated_signature(
    std::string* signature) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (signature != nullptr) {
    
  } else {
    
  }
  signature_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      signature, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Signature.signature)
}

// .ACLKey writer = 2;
inline bool Signature::_internal_has_writer() const {
  return this != internal_default_instance() && writer_ != nullptr;
}
inline bool Signature::has_writer() const {
  return _internal_has_writer();
}
inline void Signature::clear_writer() {
  if (GetArena() == nullptr && writer_ != nullptr) {
    delete writer_;
  }
  writer_ = nullptr;
}
inline const ::ACLKey& Signature::_internal_writer() const {
  const ::ACLKey* p = writer_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ACLKey*>(
      &::_ACLKey_default_instance_);
}
inline const ::ACLKey& Signature::writer() const {
  // @@protoc_insertion_point(field_get:Signature.writer)
  return _internal_writer();
}
inline void Signature::unsafe_arena_set_allocated_writer(
    ::ACLKey* writer) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(writer_);
  }
  writer_ = writer;
  if (writer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Signature.writer)
}
inline ::ACLKey* Signature::release_writer() {
  auto temp = unsafe_arena_release_writer();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ACLKey* Signature::unsafe_arena_release_writer() {
  // @@protoc_insertion_point(field_release:Signature.writer)
  
  ::ACLKey* temp = writer_;
  writer_ = nullptr;
  return temp;
}
inline ::ACLKey* Signature::_internal_mutable_writer() {
  
  if (writer_ == nullptr) {
    auto* p = CreateMaybeMessage<::ACLKey>(GetArena());
    writer_ = p;
  }
  return writer_;
}
inline ::ACLKey* Signature::mutable_writer() {
  // @@protoc_insertion_point(field_mutable:Signature.writer)
  return _internal_mutable_writer();
}
inline void Signature::set_allocated_writer(::ACLKey* writer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete writer_;
  }
  if (writer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(writer);
    if (message_arena != submessage_arena) {
      writer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, writer, submessage_arena);
    }
    
  } else {
    
  }
  writer_ = writer;
  // @@protoc_insertion_point(field_set_allocated:Signature.writer)
}

// int32 userId = 3;
inline void Signature::clear_userid() {
  userid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Signature::_internal_userid() const {
  return userid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Signature::userid() const {
  // @@protoc_insertion_point(field_get:Signature.userId)
  return _internal_userid();
}
inline void Signature::_internal_set_userid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  userid_ = value;
}
inline void Signature::set_userid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_userid(value);
  // @@protoc_insertion_point(field_set:Signature.userId)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_message_2eproto
